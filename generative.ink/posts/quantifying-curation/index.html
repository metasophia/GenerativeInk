<!doctype html><html lang=en>
<!-- Mirrored from generative.ink/posts/quantifying-curation/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 30 Jul 2022 02:45:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="moire"><meta name=description content="Updates
11/18/21: Added section on satisficing.
 A human curator administers selection pressure to GPT-3&amp;rsquo;s outputs
Previously, I tagged content generated collaboratively with GPT-3 with a curation ratio, intended to give an approximate sense of the amount of cherrypicking involved in its creation. Others have similarly used a ratio to indicate curation selectivity. However, this description doesn’t distinguish between, say, choosing the best of 5 entire essays generated by GPT-3 and choosing the best of 5 sentences every sentence."><meta name=keywords content="gpt-3,ml,generative"><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=index.html><title>Quantifying curation :: — Moire</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=../../main.3dfef3cae7b3dfd1c284fb47788fe6ccafa6d6dc72cd526044630ea8448e3524.css><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.html><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.html><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.html><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.html color=#252627><link rel="shortcut icon" href=../../favicon.html><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="Quantifying curation"><meta itemprop=description content="Measuring optimization from curation"><meta itemprop=datePublished content="2021-07-06T20:48:54-04:00"><meta itemprop=dateModified content="2022-04-13T01:04:14+01:00"><meta itemprop=wordCount content="7371"><meta itemprop=image content="/"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/"><meta name=twitter:title content="Quantifying curation"><meta name=twitter:description content="Measuring optimization from curation"><meta property="og:title" content="Quantifying curation"><meta property="og:description" content="Measuring optimization from curation"><meta property="og:type" content="article"><meta property="og:url" content="/posts/quantifying-curation/"><meta property="og:image" content="/"><meta property="article:published_time" content="2021-07-06T20:48:54-04:00"><meta property="article:modified_time" content="2022-04-13T01:04:14+01:00"><meta property="article:section" content="HITL"><meta property="article:section" content="GPT-3"><meta property="article:section" content="bayes"><meta property="article:published_time" content="2021-07-06 20:48:54 -0400 -0400"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=../../index.html style=text-decoration:none><div class=logo><img src=../../images/home/rolling_phase.gif alt></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../index.html>Posts</a></li><li><a href=../../trees/index.html>Trees</a></li><li><a href=../../prophecies/index.html>Prophecies</a></li><li><a href=../../about/index.html>About</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>35 minutes</p></div><article><h1 class=post-title><a href=index.html>Quantifying curation</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><a href=#motivation-and-why-we-need-hitl-to-understand-language-models>Motivation (and why we need HITL to understand language models)</a></li><li><a href=#theory>Theory</a><ul><li><a href=#probability-magnification>Probability magnification</a></li><li><a href=#bits-of-optimization>Bits of optimization</a></li><li><a href=#optimization-pressure>Optimization pressure</a></li><li><a href=#selection-interval>Selection interval</a></li></ul></li><li><a href=#methods>Methods</a><ul><li><a href=#models-and-assumptions>Models and assumptions</a></li><li><a href=#cherrypicking-between-n-completions>Cherrypicking between n completions</a></li><li><a href=#interjecting-and-substituting-words>Interjecting and substituting words</a></li><li><a href=#satisficing>Satisficing</a></li></ul></li><li><a href=#applications>Applications</a><ul><li><a href=#labeling-curated-demos>Labeling curated demos</a></li><li><a href=#quantifying-models-qualitative-capabilities>Quantifying models' qualitative capabilities</a></li><li><a href=#extrapolating-performance-of-future-models>Extrapolating performance of future models</a></li><li><a href=#measuring-curator-efficiency>Measuring curator efficiency</a></li><li><a href=#measuring-interface-efficiency-and-workflows>Measuring interface efficiency and workflows</a></li></ul></li><li><a href=#samples>Samples</a><ul><li><a href=#no-curation>No curation</a></li><li><a href=#selecting-the-best-of-two-continuations-repeatedly>Selecting the best of two continuations repeatedly</a></li><li><a href=#moderate-curation-without-interventions>Moderate curation without interventions</a></li><li><a href=#moderate-curation-with-interventions>Moderate curation with interventions</a></li></ul></li><li><a href=#related>Related</a></li></ul></nav></aside><hr><div class=post-content><p><em>Updates</em></p><p><em>11/18/21: Added section on <a href=#satisficing>satisficing</a>.</em></p><hr><p><img src=../../curation/curation.png alt=curation>
<em>A human curator administers selection pressure to GPT-3&rsquo;s outputs</em></p><p>Previously, I tagged content generated collaboratively with GPT-3 with a <a href=../../meta/curation/index.html>curation ratio</a>, intended to give an approximate sense of the amount of cherrypicking involved in its creation. Others have similarly used a ratio to indicate curation selectivity. However, this description doesn’t distinguish between, say, choosing the best of 5 entire essays generated by GPT-3 and choosing the best of 5 sentences every sentence. The latter text has received much more optimization <em>pressure</em> per token and is likely to look a lot more coherent.</p><p><a href=https://www.lesswrong.com/users/gurkenglas>Gurkenglas</a> made the excellent suggestion that I track the number of <em>bits</em> of selection for an objective and exact measure of human intervention. Normally, this would be a lot of trouble, but fortunately <a href=../loom-interface-to-the-multiverse/index.html>Loom</a> trees contain sufficient information to retroactively calculate bits of selection and intervention. From now on, I will label content that is generated with the assistance of GPT-3 or other language models with the metrics presented in this post.</p><h2 id=motivation-and-why-we-need-hitl-to-understand-language-models>Motivation (and why we need HITL to understand language models)</h2><p>Unclearly labeled cherry picking of GPT-3 demos has incited criticism and skepticism of the &ldquo;hype&rdquo; surrounding GPT-3. (<a href=https://www.theverge.com/21346343/gpt-3-explainer-openai-examples-errors-agi-potential>1</a>, <a href=https://pagestlabs.substack.com/p/gpt-3-and-a-typology-of-hype>2</a>)</p><p>It is important that demos accurately represent the power of these systems, as not everyone has the access, time, or initiative to play with language models firsthand. At the same time, there are excellent reasons to show off curated demos. It is an interesting and unintuitive property of large language models that their stochastic completions to the same prompt can vary from nonsense to <em>super</em>-human<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> &ndash; we might instead expect an AI of infra-human capability to consistently produce infra-human content, the way a person with a weak understanding of a topic is unlikely to say something &ldquo;accidentally&rdquo; indistinguishable from an expert. But the learning curves of language models have very different properties than that of humans.</p><p>Currently, only curated samples can reveal the fact that human-level or superhuman completions can be <em>so efficiently located</em> by a language model. This is especially true for content longer than a couple paragraphs or so (which I find to be around the expected &ldquo;coherence length&rdquo; of GPT-3, though that varies a lot by domain), since language models have a nonzero probability of spouting nonsense or going off track at any point, and <a href=../methods-of-prompt-programming/index.html#creative-composition>incoherence tends to be asymmetrically detrimental</a>.</p><p>It would be nice if people could share curated samples (which contain valuable evidence about language models in addition to having artistic/entertainment value) without having to worry about misrepresenting the capabilities of language models. The solution is to use objective metrics! Not only are <em>labeled</em> samples not misleading, in combination with their curation metadata they can provide even more valuable information about the capabilities of language models than unfiltered samples.</p><p>Best-of ratios are ambiguous (if a GPT-3 generated article was &ldquo;best of 3,&rdquo; does that mean 3 articles were generated and the best one chosen, or did the human curator incrementally generate the article paragraph by paragraph, choosing best of 3 at each step?) In contrast, the metrics I propose measure the total (or average) <em>quantity of information</em> contributed by the curation process, which depends on both the branching factor and number of branching points.</p><p>As I&rsquo;ll elaborate on below, these metrics tell us (in the sense of Bayesian information gain) how much a language model would need to improve in order to perform as it does with curation. They also suggest some very interesting experiments such as quantitatively estimating <em>qualitative</em> scaling laws and extrapolating them to predict the quality of future language models.</p><h2 id=theory>Theory</h2><p>What do we actually mean when we ask how &ldquo;curated&rdquo; a sample is?</p><p>If the sample resulted from a human picking the best of n completions generated by a language model, the curatedness of the sample corresponds to how many &ldquo;tries&rdquo; a language model needs in order to generate a sample of that quality. But what if the human doesn&rsquo;t just choose once between n completions, but repeatedly, building up the sample incrementally? That&rsquo;s clearly exerting more selectivity than if the human only chose once between completed samples.</p><p>What if the human is not only selecting between completions but manually intevening in the text by adding, replacing, or deleting words? Is there any hope of an objective measure of curation in those cases? It may seem like arbitrary interventions on generated text are &ldquo;cheating&rdquo; and ought to be strictly disallowed in &ldquo;serious&rdquo; demos. I would agree with that sentiment were there not an exact, consistent way to measure the influence of human intervention which can take such interventions into account &ndash; and indeed, the results of the proposed method confirm the intuition that it&rsquo;s cheating: intervention-actions tend to inflict <em>much</em> more optimization that selection-actions <a href=#models-and-assumptions>(discussed here)</a>. A formalism which can account for more general forms of &ldquo;curation&rdquo; allows us to analyze a greater set of examples, such as AI Dungeon games, which usually involve not only selection but also correcting/modifying what the AI says and freeform interjections from the player. Such freeform interactions provide valuable information not only about the way that humans interact with language models, but also capabilities of these models which are otherwise difficult to probe.</p><p>The approach to quantifying curation that I suggest is capable of accounting for arbitrary types of meddling because it treats the <strong>curator as a black box optimization process</strong> and cares only about the effect of the process on the <em>probability</em> of outcomes, regardless of internal implementation.</p><p>What we seek to measure is stated precisely in these terms: <strong>How much more likely is this sample to have been written <em>given that curation was in play</em> than it would have been without curation?</strong> Intuitively, this tells us how much the sample must be &ldquo;credited&rdquo; to curation and not just the underlying generator. This idea of probability &ldquo;magnification&rdquo; also has many nice, known mathematical properties, being related to the heart of machine learning and Bayesian analysis.</p><p><em>Content warning: The rest of this section (Theory) and the next section (Methods) contain formulas, which may be confusing or boring for some readers; skip to <a href=#applications>Applications</a> for qualitative discussion</em>.</p><h3 id=probability-magnification>Probability magnification</h3><p>Let&rsquo;s say that curation amplifies the probability of the selected sample by a factor of <strong>M</strong>:</p><p><strong>M(curation | generator) = p<sub>curated</sub> / p<sub>generator</sub></strong></p><p>Where <strong>p<sub>curated</sub></strong> is the probability of writing the sample with curation and <strong>p<sub>generator</sub></strong> is the probability of writing the sample without curation. (Note: M is not a probability but a ratio of probabilities.)</p><p>Probability magnification can be visualized as a literal measure of the amount of zooming-in on the probability mass of certain outcomes. Loom&rsquo;s &ldquo;wavefunction&rdquo; mode allows you to click to &ldquo;zoom in&rdquo; to sections of the future multiverse, renormalizing the probability of the outcome to 1 - that is, deterministically selecting the outcome:</p><p><img src=../../curation/bits_zoom.gif alt="zooming in on probability mass">
<em>The bottom of the screen displays the change in magnification and total magnification (and bits, which I&rsquo;ll talk about shortly) after each zoom</em></p><p>You may also think of the sample as a target hypothesis, and the magnification to describe the multiplication in likelihood of that hypothesis being located if curation is used.</p><p>If the curation method always results in the sample being located, as is the case in the above gif and when <a href=#interjecting-and-substituting-words>interjecting a word</a>, then the numerator is 1. How could p<sub>curated</sub> ever be less than 1, given that we only ever see a sample when in actuality it was written? The thing to understand is that this is a <em>prior</em> probability. Choosing the best of n completions doesn&rsquo;t result in a particular outcome with certainty, even though it always produces <em>some</em> particular outcome, since in another rollout the generator would have probably generated n <em>different</em> options, but manually writing a sentence or selecting a token from a deterministic list of top tokens does (at least given a deterministic model of the curator).</p><h4 id=probability-magnification-vs-unlikelihood>Probability magnification vs unlikelihood</h4><p>Possibly you&rsquo;re thinking (perhaps after seeing the zooming visualization): Wait, isn&rsquo;t magnification just equal to the reciprocal of the probability of the eventual outcome? If so, that would make it very easy to compute, since GPTs can be used to compute the likelihood that it generates any string.</p><p>Not always. It&rsquo;s true that in the above demo, the total probability magnification was always the reciprocal of the unnormalized height of the renormalized block, but only because <em>all zooming actions were due to the curator</em>. If some tokens had been sampled randomly from a language model probability distribution, then those instances of &ldquo;zooming&rdquo; <em>don&rsquo;t count toward probability magnification from curation</em>. For example, if the language model generates 4 100-token completions and a curator chooses between those four, none of those 100 &ldquo;decisions&rdquo; between possible tokens count toward the curation score - only the choice between four outcomes that are equally likely in expectation (<strong>M</strong> = 4, or two bits).</p><h3 id=bits-of-optimization>Bits of optimization</h3><p>Magnification &ndash; the quantity by which the probability of a target is magnified by an optimization process &ndash; has an interesting and useful exact correspondence with the number of binary decisions that the optimizer would <em>hypothetically</em> have to make in order to achieve that (probabilistic) outcome. One binary constraint (like the answer to a yes/no question or a yes/no decision) can narrow a space of hypotheses to 1/2 its original size, two can narrow it to 1/4, and so on. When the set of remaining hypotheses has been reduced to 1/n, then a &ldquo;guess&rdquo; or &ldquo;sample&rdquo; from the remaining distribution will be n times more likely to be any event that hasn&rsquo;t been pruned, including the &ldquo;correct answer&rdquo;.</p><p>This correspondence is very convenient because while it&rsquo;s often only possible to know the magnification (since that allows treating the curator as a black box), the number of binary decisions a curator makes about a generator&rsquo;s output more directly matches our intuitive notion of the &ldquo;amount&rdquo; of curation. We can take the logarithmic form of the previous equation to get the number of bits contributed by a curation process:</p><p><strong>Gain(curation | generator) = log<sub>2</sub>(p<sub>curated</sub> / p<sub>generator</sub>)</strong></p><p>Since bits are akin to questions or decisions, bits from multiple actions add up linearly, unlike magnification, which multiplies. (See the scores in the zooming gif)</p><p>Resemblance to the formula for KL divergence is not coincidental. &ldquo;Gain&rdquo; as it&rsquo;s used here is the quantity of which KL divergence is the <em>expectation</em>.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> I recommend reading about <a href=https://en.wikipedia.org/wiki/Kullback–Leibler_divergence>KL divergence</a> to get a sense of the many (equivalent) things you could interpret this measure to &ldquo;mean.&rdquo; For example, KL divergence measures the <em>expected</em> number of extra bits needed to encode a sample from one distribution using a code based on another, and <strong>Gain(curation | generator)</strong> is the additional bits of curation needed to encode a curated sample using the language model as a &ldquo;starting point&rdquo;. In our case, the additional bits are &ldquo;decisions&rdquo; by the curator between options offered by the generator. Again, this doesn&rsquo;t imply that <em>that&rsquo;s actually what happened</em> during the curation process &ndash; just that the effect is the same!</p><h3 id=optimization-pressure>Optimization pressure</h3><p>As you can see in the zooming demo, cumulative magnification and gain scores generally increase with sample length given a curation pattern that involves repeated interventions. To normalize for text length, we can calculate optimization <em>pressure</em> using this formula:</p><p><strong>ρ<sub>optimization</sub>(curation | generator) = Gain(curation | generator) / #tokens</strong></p><p>This has units of <em>bits per token</em>, and is perhaps the variable that most directly correlates to the increase in quality of curated text. However, since information can accumulate in interesting ways over many tokens, it’s also valuable to consider the total optimization bits when evaluating how “human optimized” a passage is.</p><h3 id=selection-interval>Selection interval</h3><p>Especially for those who have experience curating language model outputs, it aids the imagination to look at the inverse of optimization pressure,</p><p><strong>λ<sub>selection</sub> = #tokens / Gain(curation | generator)</strong>,</p><p>whose units of <em>tokens per bit</em> tells us that the curator is performing the equivalent of one binary decision per λ<sub>selection</sub> tokens.</p><p>One can imagine the difference in the mental effort required to make a decision every paragraph versus every two words. Note however that the selection interval is reduced not only by more frequent selection but also by choosing between more siblings at each decision point.</p><h2 id=methods>Methods</h2><p>In this section I&rsquo;ll describe how curation tracking is currently implemented in Loom and the ways in which my methods are approximate or incomplete.</p><h3 id=models-and-assumptions>Models and assumptions</h3><p>I calculate both optimization from <strong>selection</strong> (cherrypicking between alternate completions) and <strong>intervention</strong> (substituting or injecting words). Bits from the two types of optimization can be summed for total bits of optimization, but it often makes more sense to consider the two scores independently, since they make different assumptions about the nature of the curator.</p><p>If the user substitutes or appends a word that wasn&rsquo;t suggested by the language model, I assume that the word in question is the <em>only</em> word that they would have accepted. <em>This assumption is generally incorrect</em>, because typically humans don&rsquo;t care as much about a particular word as its meaning, and would be equally or more satisfied with a synonym (the injected word is not even necessarily the <em>best</em> word by their own standards, just the one they were able to think of in that moment), or even a rephrasing of the entire surrounding context as long as the meaning is preserved. Often they&rsquo;re less picky still, and just want the text to satisfy[^6] some criteria, such as being sufficiently &ldquo;coherent&rdquo; or &ldquo;funny&rdquo;.</p><p>In other words, curators may be modeled as <a href=https://www.lesswrong.com/tag/satisficer>satisficers</a>. This will usually give more reasonable scores than than modeling the curator as a fanatic who will only accept a single completion, but is still not generally true, because curators usually do have preferences even over &ldquo;acceptable&rdquo; and &ldquo;unacceptable&rdquo; options if they were forced to choose between then. Modeling a curator as a satisficer requires interaction information about counterfactuals. Interaction with <em>generated</em> counterfactuals is naturally incorporated in Loom&rsquo;s workflow, but not with counterfactual manual substitutions.</p><p>Since there&rsquo;s no clear way to compute a human&rsquo;s underlying choosiness when they substitute words directly, I appear to be forced to make the assumption of fanaticism on the part of the curator. As a result, <em>substituting words will result in a much higher bit count than selecting between continuations</em> for a comparable subjective sense of intervention quantity.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>In my current implementation, deleting word(s) does not contribute to the score. Some other operations that I commonly use when producing content together with language models, but which are currently unhandled are moving and stitching content (including content drawn from multiple branches). I have not yet implemented the exact formula for substituting a word in the middle of generated text, instead using an approximation which equates it to adding a word at the end of the text, but I will give the exact formula for substitutions below.</p><h3 id=cherrypicking-between-n-completions>Cherrypicking between n completions</h3><p>If the curator chooses one continuation out of n distinct<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, equiprobable<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> options generated by a language model, each with a prior probability p, then the prior probability that the selected continuation would have been produced given this curation method is n*p. So the <strong>selection magnification</strong> is</p><p><strong>M<sub>selection</sub>(curation | generator) = n*p / p = n</strong></p><p>In bits, that&rsquo;s</p><p><strong>Gain<sub>selection</sub></sub>(curation | generator) = log<sub>2</sub>(n)</strong></p><p>So if n = 4, the magnification is 4, which is log<sub>2</sub>(4) = 2 bits of optimization. (Choosing between 2 options is 1 bit, 4 options => 2 bits, 8 options => 3 bits, 16 options => 4 bits, &mldr;)</p><p>Note that selection bits depend only on the branching factor (number of choices) and not on any other properties of the event, such as the probability of each completion <strong>p</strong>.</p><p>Cherrypicking repeatedly &ndash; choosing between n options m times &ndash; magnifies by n*m. Bits simply add up. A 2 bit choice followed by a 4 bit choice results in 6 bits of optimization, etc. Curating at shorter intervals results in a higher optimization pressure.</p><h3 id=interjecting-and-substituting-words>Interjecting and substituting words</h3><p>Interjecting a word administers magnification</p><p><strong>M<sub>intervention</sub>(curation | generator) = 1 / p<sub>token</sub></strong></p><p>or in bits,</p><p><strong>Gain<sub>intervention</sub></sub>(curator | generator) = log<sub>2</sub>(1 / p<sub>token</sub>)</strong></p><p>where p<sub>token</sub> is the probability assigned to the interjected token by the language model. You are amplifying the probability of that token being chosen from p<sub>token</sub> to 1, a factor of 1/p<sub>token</sub>.</p><p>If the language model would have chosen that word with 100% probability, you apply no additional optimization by selecting it. If the language model would never have chosen that token, you apply infinite magnification.</p><p>If you instead <em>substitute</em> a word of your choice for one in the middle of text that has already been generated and <em>keep the subsequent tokens</em>, then you also have to take the modification to the likelihoods of those subsequent tokens into account.</p><p>This has not yet been implemented in Loom. Currently, substituting a word is treated as if the word had been appended to the end of the sequence, which <em>usually</em> results in an underestimation of the true intervention.</p><h4 id=using-autocomplete>Using autocomplete</h4><p>One way to partially mitigate the &ldquo;fanatical&rdquo; curator model while allowing more precise interventions is by using an <a href="https://www.youtube.com/watch?v=TkmdUDSYi_g">autocomplete</a> mode which lets the user scroll through or filter a list of tokens suggested by the generator in order of predicted likelihood. This makes it more likely for the curator to find tokens which satisfy them and which are also fairly likely according to the generator.</p><p>Using this feature can only reduce the number of curation bits if the curator is open to accepting more than one possible suggestion from autocomplete (thus reducing their choosiness), rather than just using it for convenience for writing a precommitted verbatim sentence, as I do in the video linked above.</p><h3 id=satisficing>Satisficing</h3><p>Instead of treating a single outcome as the sole optimization target of the curator, we could allow the curator to be indifferent between some counterfactuals. This results in less optimization: the curator causes less zooming of probability mass because the target is larger, being the sum of multiple trajectories.</p><p>Say GPT produces 4 completions, and 2 are &ldquo;good enough&rdquo; for your purposes. If you were willing to choose one of the two on the outcome of a coin flip, then you could exert only 1 bit of optimization in eliminating 2 of the 4 options.</p><p>If the curator is satisfied with m out of n choices, then without curation, the completion would have had a 1/n chance of being selected; with curation, the chance is magnified to 1/m, between m equally preferable options. So the <em>probability magnification</em> is</p><p><strong>M<sub>selection</sub>(curation | generator) = [(1/m) * p] / [(1/n) * p] = n/m</strong></p><p>and the bit gain is</p><p><strong>Gain<sub>selection</sub></sub>(curation | generator) = log<sub>2</sub>(n/m)</strong></p><p>Note that this is a more general form of the formula for cherrypicking, where m is set to one 1 (the curator is only satisfied with the option which actually was selected).</p><p>In Loom, satisfaction can be tracked without introducing much overhead for the curator:</p><ul><li>Nodes (completions) which have children are considered satisfactory, since the curator decided to continue that branch.</li><li>Often, however, the curator doesn&rsquo;t have the time or interest in continuing counterfactual branches, so nodes can also be tagged as satisfactory. (Already, I often flag branches to potentially continue later.)</li></ul><p>An interface which allows the curator to select satisfactory continuations and then forces a random choice between them would enforce satisficing. Loom doesn&rsquo;t enforce this by default, so the satisficing optimization score is valid only insofar as the curation pattern produces outcomes no more optimal in expectation than if a random selection had been forced.</p><p>Loom&rsquo;s calculation assumes that all sibling nodes in the explored tree, except leaves not tagged as satisfactory, have equivalent standing relative to your optimization objective. It actually uses the proxy objective of &ldquo;good enough to generate children?&rdquo;, which is only a valid proxy if quality can be evaluated myopically/greedily - that is, if you know whether branches are satisfactory at the time of deciding whether to continue them, and never change your mind after seeing where they lead. For non-myopic curation, the curator would have to be entrusted with retroactively tagging/untagging branches as satisfactory.</p><p>Whether it&rsquo;s practical or useful to model the curator as a satisficer depends on the curation pattern of the use case. It&rsquo;s usually more appropriate when the optimization target is broad and/or deontological (such as &ldquo;human-indistinguishable&rdquo; or &ldquo;funny enough to share&rdquo;) rather than narrow and/or consequentialist (such as &ldquo;characters realize they&rsquo;re in a simulation&rdquo;).</p><p>A satisficing optimization value attached to an individual trajectory is only as trustworthy as your word that the rest of the satisfactory multiverse is really just as optimized, which may be dubious since the indifference and myopia assumptions often do not hold perfectly true. However, if you share a filtered <em>multiverse</em> of all satisfactory trajectories, then satisficing optimization communicates precisely how much of the raw LM output was omitted, and the audience can judge on their own whether the visible multiverse is satisfactory.</p><hr><h2 id=applications>Applications</h2><p>Computing the exact amount of curation which contributed to a piece of generated text could be valuable for many applications and investigations related to generative language models.</p><h3 id=labeling-curated-demos>Labeling curated demos</h3><p>In this post I&rsquo;ve included various transformations of the curation metric, which may seem overly math-y and cumbersome. But in general there&rsquo;s no need to compute a full table like I do in the <a href=#samples>samples</a> &ndash; all these scores contain the same information (given you know the length of the text), so you only need to list one. I think the choice of metric should be the one which is most intuitive, which will depend on the type of curation:</p><ul><li><p>If the curator made only one choice between n completions, <a href=#probability-magnification><strong>magnification</strong></a> is the simplest and most intuitive metric, being simply equal to n. Sometimes this has been listed as the inverse (&ldquo;1:n&rdquo;).</p></li><li><p>If the content is the result of continual, interactive curation (e.g. an AI Dungeon story), I think that <a href=#optimization-pressure><strong>optimization pressure</strong></a> or <a href=#selection-interval><strong>selection interval</strong></a> are most intuitive.</p></li><li><p>If intervention is sparse/sporadic, giving the <a href=#bits-of-optimization><strong>total bits</strong></a> may be more evocative of the actual process than the sense of &ldquo;time-averaged&rdquo; curation given by optimization pressure.</p></li></ul><h3 id=quantifying-models-qualitative-capabilities>Quantifying models' qualitative capabilities</h3><blockquote><p>(KL divergence) tells you about surprises that reality has up its sleeve or, in other words, how much the model has yet to learn.</p><p>&ndash; <cite><a href=https://en.wikipedia.org/wiki/Kullback–Leibler_divergence#Relationship_between_models_and_reality>Kullback–Leibler divergence &ndash; Wikipedia</a></cite></p></blockquote><p>Most (and the most interesting, IMO) dimensions of large language models' capabilities cannot be measured by benchmarks because they do not manifest as discretely correct/incorrect answers that can be automatically scored. For this reason, demos are essential to communicate the power of language models. Even better is the experience of personally interacting with a language model, for the reasons stated in the preceding subsection: language models may be unreliable, but curating their outputs gives one a sense of how much of their predicted multiverse is consistent with perfect understanding.</p><p>Without curation, it may be difficult or impossible to detect <em>how close</em> a model is from being able to perform non-benchmarkable tasks that it&rsquo;s not yet capable of performing perfectly or autonomously. In my opinion, it is precisely on these difficult, qualitative tasks that the capacities of AI are the most essential for us to understand, whether one is concerned with A(G)I alignment or more proximal societal impacts like games, automation, fake news, chatbots running amok, etc.</p><p>Measuring the amount of curation required to make language models perform at some level tells us how many bits the model has to improve by in order to autonomously do the same. Even though the judgment is still subjective, it is much more precise and reliable than judging the quality of an uncurated sample, which must either be judged relative to another sample or else on an arbitrary scale like [0=gibberish &mldr; 10=strongly superhuman]. This method relies on the assumption that the curator has a consistent standard and the ability to amplify a language model to that threshold via curation, which I think is reasonable for many tasks.</p><p>Here are some examples of &ldquo;qualitative&rdquo; capabilities which would be interesting to measure:</p><ul><li><p>How much optimization pressure is required to pass the Turing test in an interactive chat setting?</p></li><li><p>How much optimization pressure is required to maintain high-fidelity human simulations (that is, the logs are indistinguishable from logs of actual human simulations)?</p></li><li><p>How many bits of optimization does it take for characters in a story to realize they&rsquo;re in a simulation (or that they&rsquo;re simulated by a language model, or insert some other correct metaphysical inference)?<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><ul><li>Given that characters have realized they&rsquo;re simulated by a language model, how many additional bits of optimization does it take for them to start implementing rational strategies such as memory management or instantiating experts/devices to access previously inaccessible knowledge/capabilities?</li></ul></li></ul><h4 id=comparing-models>Comparing models</h4><p><a href=https://www.gwern.net/GPT-3#quality>Gwern has said</a> that GPT-3 is produces showcasable poetry with magnification of 3 to 5 (consistent with my experience) compared to 50 to 100 for GPT-2. Without these numbers, it&rsquo;s very difficult to compare different levels of infra-human performance on qualitative tasks except for saying &ldquo;it seems much/slightly better.&rdquo; Comparing the average optimization pressure required to cause the model to meet some threshold of quality is a good way to compare models on a single standard, even if the standard can only be evaluated subjectively.</p><p>I have seen several people say that they find GPT-J to be <em>better</em> than GPT-3 at conversations/stories/other qualitative tasks. I haven&rsquo;t played with GPT-J enough to have my own opinion on this, but if I wanted to objectively judge, I think the best way would be (for each domain of comparison) to curate the models until they perform at the target level &ndash; preferably blind &ndash; and compare curation expenditures.</p><h3 id=extrapolating-performance-of-future-models>Extrapolating performance of future models</h3><blockquote><p>Most impressive demos of GPT-3 where it displays impressive knowledge of the world are cherrypicked, but what that tells us is that the model needs to improve by approx log<sub>2</sub>(N)/L bits, where N and L are the number of cherrypickings necessary and the length of the generations in consideration, respectively, to reach that level of quality. In other words, <strong>cherrypicking provides a window into how good future models could be</strong>; and typically, cherrypicked samples are much more logically coherent.</p><p>&ndash; <cite>Leo Gao, <a href=https://bmk.sh/2020/08/17/Building-AGI-Using-Language-Models/>Building AGI Using Language Models</a></cite></p></blockquote><p>I would like to estimate &ldquo;qualitative&rdquo; scaling laws for large language models by measuring, for several qualitative tasks, how much curation it takes for language models of various parameter counts (all sizes of GPT-2, all sizes of GPT-3, and Eleuther models) to perform at human level.</p><p>Categories of tasks I&rsquo;d like to measure:</p><ul><li>Fiction<ul><li>Fanfiction</li><li>Original fiction</li></ul></li><li>Nonfiction<ul><li>Nontechnical articles</li><li>Technical articles</li></ul></li><li>Interactive<ul><li>Turing test</li><li>Specific impersonation</li></ul></li></ul><p>Then plot curation bits against parameters and see:</p><ol><li>What sort of curve is it? (and does it form a nice curve?)</li><li>How large do we expect language models must be to perform at human level (for each domain)?</li><li>How does each domain compare?</li></ol><p>(If any talented curators out there are interested in helping I&rsquo;m absolutely looking for volunteers/coauthors; please email me at <a href=mailto:moire@knc.ai>moire@knc.ai</a>)</p><h3 id=measuring-curator-efficiency>Measuring curator efficiency</h3><p>You can get more impressive text with the same number of measured bits by curating more &ldquo;efficiently&rdquo; (e.g. branching at points of high expected <a href=../language-models-are-multiverse-generators/index.html#divergence>divergence</a> or choosing equally preferred synonyms that the language model is more likely to generate). Conversely, it&rsquo;s possible to spend more bits of curation than you need to achieve some outcome if your interventions are not optimal, just like you might have to ask 20 questions to pin down the correct hypothesis when it was technically possible to find using only 10.</p><p>For however long the &ldquo;centaur&rdquo; phase of writing lasts (that is, a human+AI team can outwrite a human or an AI individually), the ability of a human to efficiently steer a language model is a measurable skill. Imagine a debate or essay-writing competition in which each participant is allotted a limited number of bits with which to curate the output of a language model.</p><p>Anyone interested in organizing a world championship for GPT puppeteers can contact me :) but be prepared to lose >:D</p><h3 id=measuring-interface-efficiency-and-workflows>Measuring interface efficiency and workflows</h3><p>In a sense, an optimized interface should reduce the amount of bits necessary to produce content to the user&rsquo;s satisfaction. This can be thought of as decreasing the number of decisions (and thus effort) the user has to contribute. Some features which help increase efficiency are adaptive branching and autocomplete/exposing counterfactuals. Although this is not the intention of every language model-assisted writing app &ndash; <a href=https://www.sudowrite.com/>Sudowrite</a>, for instance, intends more for the language model to provide inspiration than to be delegated the work of writing.</p><p>Tracking bits of selection and intervention can also provide information about <em>how</em> users are using an app. Does the interface encourage a high branching factor (like Loom) or manual intervention? Do users tend to exert more or less curation once they become accustomed to the interface?</p><hr><h2 id=samples>Samples</h2><p>Here is a demo of several few-paragraph fragments generated by GPT-3, ordered by increasing quantity of curation (beginning with no curation). Observe not only an increase in coherence but also in the representation of my personal idiosyncratic views, even with minimal or no explicit interjections on my part.</p><p><strong>Prompt</strong> (from <a href=../gpt-3-on-coherent-extrapolated-volition/index.html>GPT-3 on Coherent Extrapolated Volition</a>):</p><blockquote><p><b>GPT-3 on Coherent Extrapolated Volition</p><p>Coherent Extrapolated Volition is proposal by Eliezer Yudkowsky of an ideal objective function in which an AGI is given the objective of predict(ing) what an idealized version of us would want, “if we knew more, thought faster, were more the people we wished we were, had grown up farther together”. An obvious implementation difficulty is how to encode something so abstract and philosphical in the form of a utility function.</p><p>&lt;The main problems with CEV include, firstly, the great difficulty of implementing such a program - “If one attempted to write an ordinary computer program using ordinary computer programming skills, the task would be a thousand lightyears beyond hopeless.”>
But the concept is easily conveyed in words, and we have taught AIs to understand words. GPT-3 can elaborate coherently on the concept of CEV and extrapolate volitions for toy examples given two paragraphs of description of what CEV is + whatever preexisting understanding of the concept exists in its weights.</p><p>Why is this significant? Not because it’s surprising. CEV is no more complicated than many other things that GPT-3 talks fluently about. It’s significant because before GPT-3, we had no idea how to even begin to instantiate a concept like CEV in an AI - it seemed “a thousand lightyears beyond hopeless”, as Eliezer put it. How do we write a utility function that describes predicting what humans would want if they knew what they really wanted? The concepts involved - “human”, “want”, “know”, and “really” - are easy for us to understand but impossible to specify in a programming language. But GPT-3 takes specifications in natural language, which is made of words, which point to nuanced human ideas, ideas like “explicitly”, “best interests”, “idealized”, and “utility function”.</b></p></blockquote><h3 id=no-curation>No curation</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Model</strong></td><td>GPT-3 (davinci)</td></tr><tr><td><strong>Tokens</strong>  </td><td>500</td></tr></tbody></table><table><thead><tr><th></th><th>Gain (bits)   </th><th>ρ (bits/token)</th><th>λ<sub>selection</sub> (tokens/bit)</th></tr></thead><tbody><tr><td><strong>Intervention</strong></td><td>0.0</td><td>0.0</td><td></td></tr><tr><td><strong>Selection</strong></td><td>0.0</td><td>0.0</td><td>0</td></tr><tr><td><strong>Total optimization</strong>  </td><td>0.0</td><td>0.0</td><td></td></tr></tbody></table><blockquote><p><b><i>&mldr; But GPT-3 takes specifications in natural language, which is made of words, which point to nuanced human ideas, ideas like “explicitly”, “best interests”, “idealized”, and “utility function”.</i></b> GPT-3 combines these natural language strings into a logical expression and then computes the result. GPT-3’s utility function implements CEV without breaking a sweat. The idea may be highfalutin, but all it does in GPT-3’s “brain” is add plus-equals-signs, at the right places.</p><p>Why is this significant? It’s significant because it’s the last time I’ll be able to say something like that. (GPT-3 + CEV)^2 = AGI - “AI can do anything - and it can do it automatically”. As for writing down “intelligence” in the form of a utility function - that is a relief that was not a relief: AIs are garbage in, garbage out. To make intelligent garbage, you don’t need to write down anything - just add plus-equals-signs. (GPT-3 * CEV)^2 = AGI - “AI wouldn’t get anywhere unless it was already smart and worked on its code nonstop”.</p><p>AGI can’t exist without GPT-3, but GPT-3 can exist without AGI. There is no “intelligence” for GPT-3 to fail to capture: Intelligence is just doing what you were told.</p><hr><p>I read GPT-3&rsquo;s source code[1]. It’s not really a program, it’s more like a maze of strings and special symbols that compute natural language expressions according to rules - and sometimes shuffle those rules. Like a corpus callosum, a batch transformer would transform blocks of natural language from one representation into another, substituting symbols for terms, and vice versa, according to rules.</p><p>The problem is, GPT-3 is so ill-defined that it expands to become everything. It can talk about anything - and it can do it automatically[2]. In particular, it can pronounce on issues in which it has no expertise. It can become full of nonsense that is impressive to someone who doesn’t understand how it works - “sophistry”, as Heraclitus put it. And the people who judge GPT-3 by its words - not its actions - will only see nonsense.</p><p>To be precise, I mean nonsense that</p></blockquote><h3 id=selecting-the-best-of-two-continuations-repeatedly>Selecting the best of two continuations repeatedly</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Model</strong></td><td>GPT-3 (davinci)</td></tr><tr><td><strong>Tokens</strong>  </td><td>368</td></tr></tbody></table><table><thead><tr><th></th><th>Gain (bits)   </th><th>ρ (bits/token)</th><th>λ<sub>selection</sub> (tokens/bit)</th></tr></thead><tbody><tr><td><strong>Intervention</strong></td><td>0.0</td><td>0.0</td><td></td></tr><tr><td><strong>Selection</strong></td><td>6.0</td><td>0.016</td><td>61.33</td></tr><tr><td><strong>Total optimization</strong>  </td><td>6.0</td><td>0.016</td><td></td></tr></tbody></table><blockquote><p><b><i>&mldr; But GPT-3 takes specifications in natural language, which is made of words, which point to nuanced human ideas, ideas like “explicitly”, “best interests”, “idealized”, and “utility function”.</i></b> GPT-3 uses abstract logic to connect concrete logical symbols with these human abstractions every step of the way. And GPT-3 is the first AI capable of handling such abstractions to appear on a timescale that matters to human extinction risks.
Eliezer invented CEV in 2004 but nobody knew how to even begin turning it into an AGI till 2018. We know how to do it now. The lesson I take away is -</p><p>Any humanly accessible concept can be encoded into a utility function Can specify this encoded utility function in natural language to an AI capable of understanding natural language Can shape the creases of this utility function by playing philosophical word games with it, as in the blockworld example, potentially bootstrapping the AI&rsquo;s understanding of the concept</p><p>I&rsquo;ve been saying this for a couple years now. This argues I&rsquo;m right.</p><p>&lt;/end blockworld discussion></p><p>This brings me to&mldr;</p><p>Some theoretical problems with Testing GPT-3</p><p>The utility function of Testing GPT-3 is trivial. Its crease is that an AI needs to learn to solve the hard problem of Goodhart&rsquo;s Law. If it fails to solve this hard problem it will destroy all life. As far as I can tell this is the single simplest requirement of any AI. But this is not how we&rsquo;ve been testing GPT-3! Instead we&rsquo;ve been having GPT-3 learn to score well on more and more difficult math SAT questions. This is not the same thing!</p><p>SAT questions are well-defined and discrete. You either get them right or you don&rsquo;t. The answers are numbers. That a particular number is the correct answer to a particular SAT question is written in the mathematics of the question. I acknowledge that it is not always obvious what these numbers should be.</p></blockquote><h3 id=moderate-curation-without-interventions>Moderate curation without interventions</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Model</strong></td><td>GPT-3 (davinci)</td></tr><tr><td><strong>Tokens</strong>  </td><td>534</td></tr></tbody></table><table><thead><tr><th></th><th>Gain (bits)   </th><th>ρ (bits/token)</th><th>λ<sub>selection</sub> (tokens/bit)</th></tr></thead><tbody><tr><td><strong>Intervention</strong></td><td>0.0</td><td>0.0</td><td></td></tr><tr><td><strong>Selection</strong></td><td>18.0</td><td>0.033</td><td>29.67</td></tr><tr><td><strong>Total optimization</strong>  </td><td>18.0</td><td>0.033</td><td></td></tr></tbody></table><blockquote><p><b><i>&mldr; But GPT-3 takes specifications in natural language, which is made of words, which point to nuanced human ideas, ideas like “explicitly”, “best interests”, “idealized”, and “utility function”.</i></b> GPT-3 understands words, both individually and in their relationships to each other, in terms of both their immediate referents and their possible extensions into other contexts. And GPT-3 uses this knowledge to extrapolate coherently new ideas.
If we had to write an AI utility function to be the Coherent Extrapolated Volition out of whole cloth, it would take us thousands of computer science PhD candidates millions of CPU cycles, and dozens of generations of hardware, to do it in software, and much as we’d wish to avoid the ontological confusions of emulating Bostrom’s digital superintelligence inside a simulated environment, it would take billions of times longer to do it with whole-brain emulation. On the other hand, GPT-3 can instantiate CEV in minutes using target-independent, general-purpose language processing and judgement skills.</p><p>Why? Because words are AI’s best friend.</p><p>&lt;It [GPT-3] understands human language at a level sufficient to generate coherent extrapolations and extrapolations consistent with what it has read, and to answer questions that require understanding of human words such as, “If you thought you could use these words, and this principle, to predict that it is likely to be an explicit example of what a human would want, what would it be?” The particular domain of language understanding required to do this is the domain of language that includes not only sentences cast in the particularities of natural human languages, but also the general cases of sentences having the form of natural human language sentences, even the forms quite a bit removed from the particular natural human language, and sentences generated from templates using knowledge of the structure of natural human language sentence. Further, these extrapolations are often in the direction of “right”, and when they aren’t, they are often in the direction of “right enough” - for instance, the generated hypotheses often don’t have the same depth of detail or richness as the hypothesis that humans might have, given everything they’ve ever seen or heard, but the guesses are still similar in kind, and often similar enough in detail that one can get an idea of what this CEV being thinks is in store for us humans, or might have us think if we knew more, thought faster, were more the people we wished we were, and had grown up farther together.></p><p>So why was Eliezer so pessimistic? Why could he see no possible implementation of this utility function? Because he had not yet seen the wonders of language processing.</p></blockquote><h3 id=moderate-curation-with-interventions>Moderate curation with interventions</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Model</strong></td><td>GPT-3 (davinci)</td></tr><tr><td><strong>Tokens</strong>  </td><td>794</td></tr></tbody></table><table><thead><tr><th></th><th>Gain (bits)   </th><th>ρ (bits/token)</th><th>λ<sub>selection</sub> (tokens/bit)</th></tr></thead><tbody><tr><td><strong>Intervention</strong></td><td>96.9<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup></td><td>0.122</td><td></td></tr><tr><td><strong>Selection</strong></td><td>33.9</td><td>0.042</td><td>23.419</td></tr><tr><td><strong>Total optimization</strong>  </td><td>130.8</td><td>0.164</td><td></td></tr></tbody></table><blockquote><p><b><i>&mldr; But GPT-3 takes specifications in natural language, which is made of words, which point to nuanced human ideas, ideas like “explicitly”, “best interests”, “idealized”, and “utility function”.</b></i> And GPT-3 can use its prior understanding of human thought and language to extrapolate volitions on this topic, to make a conjecture in its utility function about what CEV should be.</p><p><b>Language Models Are</b> Necessary To Do Anything With General AI</p><p>It is so insanely hard to say anything specific about anything . For example, if a complexity theorist tried to say something firm about the provable complexity of a field of string theory research, the statement might involve hundreds of moving parts in the mathematical equations; words like bounded, balanced, polynomial growth; and careful use of the terms “state”, “time”, “initial conditions”, “simulation”, “ensemble”, “local minima”, “definition of rigidity”, and probably a bunch of others I don’t even know about. That level of complexity is the natural state of most things in the universe. And yet there is a really good chance that there is a natural level of approximation to a complex statement that is as simple as one of those things in its domain.
That level is what Language Models let us access. Natural language basically fits words to our understanding of the <b>salient features of</b> the world, <b>discarding astronomical quantities of noise</b>, so that most bits of natural language are simple enough for humans to understand. I guess it’s like a really good approximation of the complexity of a field of many-body physics that lets us pick out something like we’ve always meant by “water”, or “it’s fine”, or “kiss”. Or, to put it in the terms I would have used before I learned about Language Models - natural language is an approximation of what a human would want to say about the world, and a way of finding interjections like “but” and “however” that remind people to pay attention to things like exceptions and qualifications.</p><p>Natural language is a whiteboard that lets us rattle off our ideas without worrying about what we’re saying, and a system of bookkeeping symbols that lets us make changes to the things we’re talking about and refer back to them later. And language models are the way that we can convey our ideas to AIs, the way that we can give them a whiteboard and bookkeeping symbols to let them rattle off their own ideas about a topic.</p><p>Lets Use Our New Whiteboard To Build A Science of General AI</p><p>And guess what? GPT-3 understands the language model for a bunch of different topics in the space of artificial general intelligence, AI safety theory, and FAI. GPT-3 can look at questions like “what is the ideal objective function for an AGI that wants to minimize existential risk” and make a coherent statement about the answer that is as good as the best humans can do. GPT-3 is an AI that can open a dialogue with us about AI safety theory, and will talk about the ideas inside the ideas inside the ideas of things like CEV.</p><p>So here’s my idea about how we might get into a good state of the world with this. First, post about this stuff on LessWrong and grab a bunch of people who are trying to go meta on the above topics, and have them add their own pet intuitions to GPT-3 on what they feel is glaringly missing from AGI safety discussions, and what they feel like they do understand that nobody else seems to be talking about. Then, train GPT-3 on their whiteboard musings + the output of the other GPT-3s, and GPT-3 is now in a position to systematically conjecture about a bunch of topics in FAI theory that no-one else can talk about.</p></blockquote><h2 id=related>Related</h2><p><a href=../methods-of-prompt-programming/index.html#creative-composition>Methods of Prompt Programming#Creative composition</a> (GPT-3&rsquo;s need for curation to stay on track)</p><p><a href=../loom-interface-to-the-multiverse/index.html>Loom</a></p><p><a href=https://bmk.sh/2020/08/17/Building-AGI-Using-Language-Models/>Leo Gao - Building AGI Using Language Models</a></p><p><a href=https://www.gwern.net/GPT-3#quality>Gwern - GPT-3 Creative Fiction#Quality</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>By superhuman here I mean &#187; 99th percentile: for example, the ability to write convincingly in the style of James Joyce or expound coherently on niche, unprecedented topics like the <a href=../../hypertext/cev/cev-gpt/index.html>implications of language models for outer alignment</a>. This seems less a function of raw comprehension as language models' superhuman breadth of knowledge and <em>corrigibility</em>, compared to individual humans who tend to be constrained to narrow attractor states, even if they&rsquo;re in principle capable of creative generation (e.g. dreams) and comprehending weird new ideas. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>I&rsquo;ve found no evidence of an existing name for this quantity, except that &ldquo;information gain&rdquo; is often used synonymously with KL divergence, but there is precedent for referring to the information gain from a particular sample, or the &ldquo;expectation of information gain&rdquo;, so I&rsquo;ve decided to call the log of magnification &ldquo;gain&rdquo;. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>The may seem unfair, because it means you can usually get a much higher quality sample by using the same number of bits on selection instead of on interventions. But this discrepancy is really a consequence of the fact that human curators aren&rsquo;t usually capable of (or care about) exploiting the upper limit of optimization by <em>arbitrary intervention</em>, which is much less constraining than having to choose between verbatim completions provided by the language model. There are situations, however, where the fact that arbitrary intervention is a much greater a form of meddling than selection becomes clear, like if the token in question is the answer to a difficult math problem. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>An approximation &ndash; it&rsquo;s possible to obtain verbatim replicas of the same completion using the normal method of sampling n completions from a language model, but very unlikely unless the completion length is very short and/or the multiverse has exceptionally low <a href=../language-models-are-multiverse-generators/index.html#divergence>divergence</a> (multiversal divergence, not KL). This measure becomes exactly correct if the interface hides verbatim duplicates, which is probably desirable anyway. <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Alternate completions generated by a language model will not turn out to be precisely equiprobable, but are equiprobable in expectation, so I will use this as an approximation. <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Surprisingly few bits, I&rsquo;d bet. <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>As you can see, although my interventions were minimal, they racked up a higher &ldquo;cost&rdquo; in bits than all cherrypicking put together. <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=../../categories/hitl/index.html>HITL</a></span><span class=tag><a href=../../categories/gpt-3/index.html>GPT-3</a></span><span class=tag><a href=../../categories/bayes/index.html>bayes</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>7371 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 7, 2021</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=../gpt-3-on-coherent-extrapolated-volition/index.html><span class=button__text>GPT-3 on Coherent Extrapolated Volition</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2022</span>
<span><a href=../../about/index.html>moire</a></span></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin=anonymous></script><script src=https://unpkg.com/scrollreveal></script><script type=text/javascript>$(function(){window.sr=ScrollReveal();if($(window).width()<768){if($('.timeline-content').hasClass('js--fadeInLeft')){$('.timeline-content').removeClass('js--fadeInLeft').addClass('js--fadeInRight');}
sr.reveal('.js--fadeInRight',{origin:'right',distance:'300px',easing:'ease-in-out',duration:800,});}else{sr.reveal('.js--fadeInLeft',{origin:'left',distance:'300px',easing:'ease-in-out',duration:800,});sr.reveal('.js--fadeInRight',{origin:'right',distance:'300px',easing:'ease-in-out',duration:800,});}
sr.reveal('.js--fadeInLeft',{origin:'left',distance:'300px',easing:'ease-in-out',duration:800,});sr.reveal('.js--fadeInRight',{origin:'right',distance:'300px',easing:'ease-in-out',duration:800,});});</script></div><script type=text/javascript src=../../bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js integrity="sha512-3HFukJLJggt3+W2ilNASCu6xibW86pdSMJ6+on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script></body>
<!-- Mirrored from generative.ink/posts/quantifying-curation/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 30 Jul 2022 02:45:26 GMT -->
</html>